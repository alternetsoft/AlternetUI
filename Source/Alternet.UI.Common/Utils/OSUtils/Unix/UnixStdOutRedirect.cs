using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

namespace Alternet.UI
{
    /// <summary>
    /// Redirects native Linux standard output and error streams to memory, allowing
    /// capturing and handling of their output within managed code.
    /// </summary>
    public class UnixStdOutRedirect : DisposableObject
    {
        private static UnixStdOutRedirect? stdOutRedirect;
        private static UnixStdOutRedirect? stdErrRedirect;

        private readonly int[] stdOutPipe = new int[2];

        /// <summary>
        /// Occurs when a line is received from the redirected standard output stream.
        /// </summary>
        public static event Action<string>? StdOutReceived;

        /// <summary>
        /// Occurs when a line is received from the redirected standard error stream.
        /// </summary>
        public static event Action<string>? StdErrReceived;

        /// <summary>
        /// Redirects the standard error stream to memory on macOS.
        /// </summary>
        /// <remarks>This method is only applicable when the application is running on macOS.
        /// It redirects the native standard error stream to an in-memory buffer,
        /// which can be useful for capturing error
        /// messages generated by native libraries.</remarks>
        public static void RedirectStdErrOnMacOs()
        {
            if (App.IsMacOS)
                RedirectNativeStdErrToMemory();
        }

        /// <summary>
        /// Redirects the native standard output stream to memory.
        /// </summary>
        public static void RedirectNativeStdOutToMemory()
        {
            try
            {
                if (stdOutRedirect is not null)
                    return;

                stdOutRedirect = new UnixStdOutRedirect();
                stdOutRedirect.RedirectNativeStdOutToMemory(redirectStdErr: false, StdOutReceived);
            }
            catch(Exception ex)
            {
                Debug.WriteLine(ex);
                SafeDisposeSuppressException(ref stdOutRedirect);
            }
        }

        /// <summary>
        /// Redirects the native standard error stream to memory.
        /// </summary>
        public static void RedirectNativeStdErrToMemory()
        {
            if (stdErrRedirect is not null)
                return;
            try
            {
                stdErrRedirect = new UnixStdOutRedirect();
                stdErrRedirect.RedirectNativeStdOutToMemory(redirectStdErr: true, StdErrReceived);
            }
            catch(Exception ex)
            {
                Debug.WriteLine(ex);
                SafeDisposeSuppressException(ref stdErrRedirect);
            }
        }

        /// <summary>
        /// Stops redirecting the standard output stream.
        /// </summary>
        public static void StopRedirectingStdOut()
        {
            SafeDispose(ref stdOutRedirect);
        }

        /// <summary>
        /// Stops redirecting the standard error stream.
        /// </summary>
        public static void StopRedirectingStdErr()
        {
            SafeDispose(ref stdErrRedirect);
        }

        /// <summary>
        /// Disposes managed resources and cleans up redirection.
        /// </summary>
        protected override void DisposeManaged()
        {
            CleanupRedirection();
            base.DisposeManaged();
        }

        /// <summary>
        /// Redirects either the standard output or error stream to memory and
        /// invokes the callback for each line received.
        /// </summary>
        /// <param name="redirectStdErr">If true, redirects standard error; otherwise,
        /// redirects standard output.</param>
        /// <param name="callback">Callback to invoke for each line received.</param>
        private bool RedirectNativeStdOutToMemory(bool redirectStdErr, Action<string>? callback = null)
        {
            int idx = redirectStdErr ? 2 : 1;

            // stdOutPipe[0] = read end, stdOutPipe[1] = write end
            var result = LinuxUtils.NativeMethods.pipe(stdOutPipe);
            if (result != 0)
            {
                Debug.WriteLine("Failed to create pipe for StdOut redirection.");
                return false;
            }

            result = LinuxUtils.NativeMethods.dup2(stdOutPipe[1], idx);
            if (result != 0)
            {
                Debug.WriteLine("Failed to duplicate file descriptor for StdOut redirection.");
                return false;
            }

            // Start a thread to read from the pipe
            var thr = new Thread(() =>
            {
                using var reader = new FileStream(
                    new Microsoft.Win32.SafeHandles.SafeFileHandle(
                        (IntPtr)stdOutPipe[0],
                        ownsHandle: false),
                    FileAccess.Read);

                using var sr = new StreamReader(reader);

                while (true)
                {
                    string? line = sr.ReadLine();
                    if (line != null)
                        callback?.Invoke(line);
                }
            });

            thr.IsBackground = true;
            thr.Start();
            return true;
        }

        /// <summary>
        /// Cleans up the redirection by closing pipe handles.
        /// </summary>
        private void CleanupRedirection()
        {
            try
            {
                LinuxUtils.NativeMethods.close(stdOutPipe[0]);
                LinuxUtils.NativeMethods.close(stdOutPipe[1]);
            }
            catch
            {
            }
        }
    }
}
