using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

using Microsoft.Win32.SafeHandles;

namespace Alternet.UI
{
    /// <summary>
    /// Redirects native Linux standard output and error streams to memory, allowing
    /// capturing and handling of their output within managed code.
    /// </summary>
    public class UnixStdStreamRedirector : DisposableObject
    {
        private static UnixStdStreamRedirector? stdOutRedirect;
        private static UnixStdStreamRedirector? stdErrRedirect;

        private readonly int[] redirectPipe = new int[2];
        private readonly CancellationTokenSource cancellation = new();
        private Thread? readerThread;
        private bool pipeClosed;

        /// <summary>
        /// Initializes a new instance of the <see cref="UnixStdStreamRedirector"/> class.
        /// </summary>
        /// <remarks>This class is designed to handle standard output and error redirection on Unix-based
        /// systems.</remarks>
        public UnixStdStreamRedirector()
        {
        }

        /// <summary>
        /// Occurs when a line is received from the redirected standard output stream.
        /// </summary>
        public static event Action<string>? StdOutReceived;

        /// <summary>
        /// Occurs when a line is received from the redirected standard error stream.
        /// </summary>
        public static event Action<string>? StdErrReceived;

        /// <summary>
        /// Redirects the standard error stream to memory on macOS.
        /// </summary>
        /// <remarks>This method is only applicable when the application is running on macOS.
        /// It redirects the native standard error stream to an in-memory buffer,
        /// which can be useful for capturing error
        /// messages generated by native libraries.</remarks>
        public static void RedirectStdErrOnMacOs()
        {
            if (App.IsMacOS)
                RedirectNativeStdErrToMemory();
        }

        /// <summary>
        /// Redirects the native standard output stream to memory.
        /// </summary>
        public static void RedirectNativeStdOutToMemory()
        {
            try
            {
                if (stdOutRedirect is not null)
                    return;

                stdOutRedirect = new UnixStdStreamRedirector();
                stdOutRedirect.StartRedirectingStream(redirectStdErr: false, StdOutReceived);
            }
            catch(Exception ex)
            {
                Debug.WriteLine(ex);
                SafeDisposeSuppressException(ref stdOutRedirect);
            }
        }

        /// <summary>
        /// Redirects the native standard error stream to memory.
        /// </summary>
        public static void RedirectNativeStdErrToMemory()
        {
            if (stdErrRedirect is not null)
                return;
            try
            {
                stdErrRedirect = new UnixStdStreamRedirector();
                stdErrRedirect.StartRedirectingStream(redirectStdErr: true, StdErrReceived);
            }
            catch(Exception ex)
            {
                Debug.WriteLine(ex);
                SafeDisposeSuppressException(ref stdErrRedirect);
            }
        }

        /// <summary>
        /// Stops redirecting the standard output stream.
        /// </summary>
        public static void StopRedirectingStdOut()
        {
            SafeDispose(ref stdOutRedirect);
        }

        /// <summary>
        /// Stops redirecting the standard error stream.
        /// </summary>
        public static void StopRedirectingStdErr()
        {
            SafeDispose(ref stdErrRedirect);
        }

        /// <summary>
        /// Disposes managed resources and cleans up redirection.
        /// </summary>
        protected override void DisposeManaged()
        {
            cancellation.Cancel();
            if (readerThread?.IsAlive == true)
            {
                readerThread.Join();
                readerThread = null;
            }

            cancellation.Dispose();
            CleanupPipe();
            base.DisposeManaged();
        }

        /// <summary>
        /// Redirects either the standard output or error stream to memory and
        /// invokes the callback for each line received.
        /// </summary>
        /// <param name="redirectStdErr">If true, redirects standard error; otherwise,
        /// redirects standard output.</param>
        /// <param name="callback">Callback to invoke for each line received.</param>
        private bool StartRedirectingStream(bool redirectStdErr, Action<string>? callback = null)
        {
            int idx = redirectStdErr ? 2 : 1;

            // stdOutPipe[0] = read end, stdOutPipe[1] = write end
            var result = LinuxUtils.NativeMethods.pipe(redirectPipe);
            if (result != 0)
            {
                LinuxUtils.LogLastNativeError(redirectStdErr ? "[pipe StdErr]" : "[pipe StdOut]");
                return false;
            }

            result = LinuxUtils.NativeMethods.dup2(redirectPipe[1], idx);
            if (result != 0)
            {
                CleanupPipe();
                LinuxUtils.LogLastNativeError(redirectStdErr ? "[dup2 StdErr]" : "[dup2 StdOut]");
                return false;
            }

            LinuxUtils.NativeMethods.close(redirectPipe[1]);

            void ReadLoop(Action<string>? callback)
            {
                using var handle = new SafeFileHandle((IntPtr)redirectPipe[0], ownsHandle: true);
                using var stream = new FileStream(handle, FileAccess.Read);
                using var reader = new StreamReader(stream, Encoding.UTF8);

                try
                {
                    while (!cancellation.Token.IsCancellationRequested)
                    {
                        var line = reader.ReadLine();
                        if (line == null) break;
                        callback?.Invoke(line);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Reader thread failed: {ex}");
                }
            }

            readerThread = new Thread(() => ReadLoop(callback))
            {
                IsBackground = true,
                Name = redirectStdErr ? "UnixStdErrReader" : "UnixStdOutReader",
            };

            readerThread.Start();
            return true;
        }

        /// <summary>
        /// Cleans up the redirection by closing pipe handle.
        /// </summary>
        private void CleanupPipe()
        {
            if (pipeClosed) return;
            pipeClosed = true;
            try
            {
                LinuxUtils.NativeMethods.close(redirectPipe[0]);
                redirectPipe[0] = -1;
                redirectPipe[1] = -1;
            }
            catch
            {
            }
        }
    }
}
