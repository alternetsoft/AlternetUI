using System;
using System.Threading;

namespace Alternet.UI
{
    /// <summary>
    /// Contains static methods which allow to call object methods from other threads.
    /// </summary>
    public static class SynchronizationService
    {
        /// <summary>
        /// Gets a value indicating whether the caller must call an invoke method when making method
        /// calls to the UI objects because the caller is not on the UI thread.
        /// </summary>
        public static bool InvokeRequired
        {
            get
            {
                var result = App.Handler?.InvokeRequired ?? false;
                return result;
            }
        }

        /// <summary>
        /// Executes a delegate asynchronously on the UI thread.
        /// </summary>
        /// <param name="method">A delegate to a method that takes parameters
        /// of the same number and type that are contained in the args parameter.</param>
        /// <param name="args">An array of objects to pass as arguments to the
        /// given method. This can be <c>null</c> if no arguments are needed.</param>
        /// <returns>An <see cref="IAsyncResult"/> that represents the result
        /// of the operation.</returns>
        public static IAsyncResult BeginInvoke(Delegate method, object?[] args)
        {
            var handler = App.Handler ?? throw new InvalidOperationException();
            var invocation = new Invocation(method, args, synchronous: false);
            handler.BeginInvoke(invocation.GetAction());
            return invocation;
        }

        /// <summary>
        /// Retrieves the return value of the asynchronous operation represented
        /// by the <see cref="IAsyncResult"/> passed.
        /// </summary>
        /// <param name="result">The <see cref="IAsyncResult"/> that represents
        /// a specific invoke asynchronous operation, returned when calling
        /// <see cref="BeginInvoke"/>.</param>
        /// <returns>The <see cref="object"/> generated by the
        /// asynchronous operation.</returns>
        public static object? EndInvoke(IAsyncResult result)
        {
            if (result is not Invocation invocation)
                throw new ArgumentException("Invalid IAsyncResult.", nameof(result));

            result.AsyncWaitHandle.WaitOne();

            if (invocation.Exception != null)
                throw invocation.Exception;

            return invocation.ReturnValue;
        }

        /// <summary>
        /// Executes the specified delegate on the UI thread.
        /// </summary>
        /// <param name="method">A delegate that contains a method to be called
        /// in the UI thread context.</param>
        /// <returns>An <see cref="object"/> that contains the return value from
        /// the delegate being invoked, or <c>null</c> if the delegate has no
        /// return value.</returns>
        public static object? Invoke(Delegate? method)
        {
            if (method == null)
                return null;
            return Invoke(method, Array.Empty<object?>());
        }

        /// <summary>
        /// Executes the specified action on the UI thread.
        /// </summary>
        /// <param name="action">An action to be called in the UI thread context.</param>
        public static void Invoke(Action? action)
        {
            if (action == null)
                return;
            Invoke(action, Array.Empty<object?>());
        }

        /// <summary>
        /// Executes the specified delegate, on the UI thread,
        /// with the specified list of arguments.
        /// </summary>
        /// <param name="method">A delegate to a method that takes parameters of
        /// the same number and type that are contained in the
        /// <c>args</c> parameter.</param>
        /// <param name="args">An array of objects to pass as arguments to
        /// the specified method. This parameter can be <c>null</c> if the
        /// method takes no arguments.</param>
        /// <returns>An <see cref="object"/> that contains the return value
        /// from the delegate being invoked, or <c>null</c> if the delegate has
        /// no return value.</returns>
        public static object? Invoke(Delegate method, object?[] args)
        {
            if (!InvokeRequired)
                return method.DynamicInvoke(args);

            return EndInvoke(BeginInvoke(method, args));
        }

        internal class Invocation : IAsyncResult
        {
            private readonly Delegate mTargetDelegate;
            private readonly object?[] mTargetDelegateArgs;
            private readonly object mInvokeSyncObject = new();
            private readonly bool mSynchronous;
            private ManualResetEvent? mCompletedSyncEvent;

            public Invocation(Delegate targetDelegate, object?[] targetDelegateArgs, bool synchronous)
            {
                mTargetDelegate = targetDelegate;
                mTargetDelegateArgs = targetDelegateArgs;
                mSynchronous = synchronous;
            }

            ~Invocation()
            {
                mCompletedSyncEvent?.Close();
            }

            public object? AsyncState => null;

            public object? ReturnValue { get; private set; }

            public Exception? Exception { get; private set; }

            public WaitHandle AsyncWaitHandle
            {
                get
                {
                    if (mCompletedSyncEvent == null)
                    {
                        lock (mInvokeSyncObject)
                        {
                            if (mCompletedSyncEvent == null)
                            {
                                mCompletedSyncEvent = new ManualResetEvent(false);
                                if (IsCompleted)
                                    mCompletedSyncEvent.Set();
                            }
                        }
                    }

                    return mCompletedSyncEvent;
                }
            }

            public bool CompletedSynchronously => IsCompleted && mSynchronous;

            public bool IsCompleted { get; private set; }

            public Action GetAction()
            {
                var sink = new Action(
                    () =>
                    {
                        try
                        {
                            ReturnValue = mTargetDelegate.DynamicInvoke(mTargetDelegateArgs);
                        }
                        catch (Exception e)
                        {
                            Exception = e;
                        }
                        finally
                        {
                            Complete();
                        }
                    });

                return sink;
            }

            private void Complete()
            {
                lock (mInvokeSyncObject)
                {
                    IsCompleted = true;
                    mCompletedSyncEvent?.Set();
                }
            }
        }
    }
}