using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

using Alternet.UI.Extensions;

namespace Alternet.UI
{
    public class GenerateBindableSetting
    {
        public static string Copyright => $"Copyright (c) {DateTime.Now.Year} AlterNET Software";
        public static string HeaderText =>
            $"// <auto-generated> DO NOT MODIFY MANUALLY. {Copyright}.</auto-generated>";

        public bool? DisableWarnings { get; set; }

        public string? RootFolder { get; set; }

        public string? PathToDll { get; set; }

        public string? TypeName { get; set; }

        public string? PathToResult { get; set; }

        public string? ResultTypeName { get; set; }

        public string? SubPropertyName { get; set; }

        public bool? Ignore { get; set; }

        public static PathAssemblyResolver CreateAssemblyResolver(string pathToDll)
        {
            var folder = Path.GetDirectoryName(pathToDll);
            string[] runtimeAssemblies = Directory.GetFiles(folder!, "*.dll");
            var paths = new List<string>(runtimeAssemblies);
            
            paths.Add(typeof(object).Assembly.Location);

            var runTimeAssemblies
                = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");

            paths.AddRange(runTimeAssemblies);

            var resolver = new PathAssemblyResolver(paths);
            return resolver;
        }

        public bool Execute(GenerateBindableSettings globals)
        {
            if (PathToDll is null || TypeName is null || PathToResult is null
                || ResultTypeName is null || SubPropertyName is null)
                return false;

            var indent = "    ";
            var indent2 = $"{indent}{indent}";
            var indent3 = $"{indent}{indent}{indent}";

            var resolver = CreateAssemblyResolver(PathToDll);

            using var mlc = new MetadataLoadContext(resolver);

            Assembly assembly = mlc.LoadFromAssemblyPath(PathToDll);
            AssemblyName name = assembly.GetName();

            var type = assembly.GetType(TypeName);

            if(type is null)
            {
                Console.WriteLine($"Type is not found: {TypeName}");
                return false;
            }

            List<string> generatedFile = new();
            List<string> errors = new();
            List<string> internals = new();
            List<string> protecteds = new();
            List<string> privates = new();

            var lastPointPos = ResultTypeName.LastIndexOf('.');

            if (lastPointPos <= 0)
                return false;

            var resultNamespace = ResultTypeName.Substring(0, lastPointPos);
            var resultTypeNameOnly = ResultTypeName.Substring(lastPointPos + 1);

            generatedFile.Add(HeaderText);

            if(DisableWarnings ?? false)
                generatedFile.Add("#pragma warning disable");

            generatedFile.Add("#nullable enable");

            generatedFile.Add($"namespace {resultNamespace}");
            generatedFile.Add("{");
            generatedFile.Add($"{indent}public partial class {resultTypeNameOnly}");
            generatedFile.Add($"{indent}{{");

            GenerateEvents(true);
            GenerateProperties(false);
            GenerateBindEventsCall();
            GenerateUnbindEventsCall();

            EnumerableUtils.ForEach(internals, generatedFile.Add);
            EnumerableUtils.ForEach(protecteds, generatedFile.Add);
            EnumerableUtils.ForEach(privates, generatedFile.Add);

            generatedFile.Add($"{indent}}}");
            generatedFile.Add("}");

            var s = StringUtils.ToString(
                generatedFile,
                string.Empty,
                string.Empty,
                Environment.NewLine);

            FileUtils.StringToFileIfChanged(PathToResult, s);

            if (errors.Count > 0)
            {
                Console.WriteLine();
                Console.WriteLine("Errors:");
                Console.WriteLine();
                EnumerableUtils.ForEach(errors, Console.WriteLine);
                Console.WriteLine();
            }

            Console.WriteLine();
            Console.WriteLine();

            return true;

            void GenerateProperties(bool first)
            {
                var props = type.GetProperties(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);

                Console.WriteLine();
                Console.WriteLine("Properties:");
                Console.WriteLine();

                foreach (var prop in props)
                {
                    var canWrite = prop.CanWrite
                        ? $"set => {SubPropertyName}.{prop.Name} = value; " : string.Empty;
                    var canRead = prop.CanRead
                        ? $"get => {SubPropertyName}.{prop.Name}; " : string.Empty;
                    
                    var propType = TypeToCodeString(prop.PropertyType);
                    if (propType is null)
                        continue;
                    
                    /*if (!TypeNameIsValid(propType.TrimEnd('[', ']', ',')))
                    {
                        errors.Add($"ERROR: Property '{prop.Name}' has unsupported type: {propType}");
                        continue;
                    }*/

                    var realType = AssemblyUtils.GetRealType(prop.PropertyType);
                    var typeCode = Type.GetTypeCode(realType);

                    var inheritDocDecl
                        = $"{indent2}/// <inheritdoc cref=\"{TypeName}.{prop.Name}\"/>";

                    var generatedDecl
                        = $"{indent2}public {propType} {prop.Name} {{ {canRead}{canWrite}}}";

                    Console.WriteLine(generatedDecl);
                    if (first)
                        first = false;
                    else
                        generatedFile.Add(string.Empty);
                    generatedFile.Add(inheritDocDecl);
                    generatedFile.Add(generatedDecl);
                }
            }

            bool TypeNameIsValid(string? typeNameToCheck)
            {
                return true;
                /*return StringUtils.HasOnlyValidChars(
                    typeNameToCheck,
                    StringUtils.IsEnglishCharOrDot);*/
            }

            /*string? ChangeAliasedType(Type? type)
            {
                var t = type?.FullName;

                if (t is null)
                    return null;

                if (type?.IsArray ?? false)
                    return t;

                foreach (var item in globals.TypeAliases)
                {
                    if (item.TypeName == t)
                    {
                        return item.ChangeTo;
                    }
                }

                return t;
            }*/

            void GenerateBindUnbindCall(string bindName, string operation, string xmlHelp)
            {
                var generatedDecl1
                    = $"{indent2}/// {xmlHelp}.";
                var generatedDecl2
                    = $"{indent2}protected virtual void {bindName}({TypeName} obj)";
                var generatedDecl3 = $"{indent2}{{";
                protecteds.Add(string.Empty);
                protecteds.Add(generatedDecl1);
                protecteds.Add(generatedDecl2);
                protecteds.Add(generatedDecl3);

                var events = GetEvents();

                foreach (var ev in events)
                {
                    if (!EventIsOk(ev))
                        continue;
                    var generatedDecl = $"{indent3}obj.{ev.Name} {operation}= {ev.Name}Handler;";
                    protecteds.Add(generatedDecl);
                }

                var generatedDecl4 = $"{indent2}}}";
                protecteds.Add(generatedDecl4);
            }

            void GenerateBindEventsCall()
            {
                GenerateBindUnbindCall("BindToEvents", "+", "Binds to the events");
            }

            void GenerateUnbindEventsCall()
            {
                GenerateBindUnbindCall("UnbindFromEvents", "-", "Undinds from the events");
            }

            EventInfo[] GetEvents()
            {
                var events = type.GetEvents(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);
                return events;
            }

            bool EventIsOk(EventInfo ev)
            {
                var handlerType = ev.EventHandlerType;
                if (handlerType is null)
                    return false;

                var eventArgsType = AssemblyUtils.GetEventArgsType(ev);
                if (eventArgsType is null)
                    return false;

                var handlerTypeName = handlerType.ToString();
                if (!TypeNameIsValid(handlerTypeName))
                    return false;

                return true;
            }

            string TypeToCodeString(Type type)
            {
                return AssemblyUtils.GetTypeNameUsingCodeDom(type);
            }

            void GenerateEvents(bool first)
            {
                var events = GetEvents();

                Console.WriteLine();
                Console.WriteLine("Events:");
                Console.WriteLine();

                foreach (var ev in events)
                {
                    var evText = ev.ToString();

                    var handlerType = ev.EventHandlerType;
                    if (handlerType is null)
                        continue;

                    var eventArgsType = AssemblyUtils.GetEventArgsType(ev);
                    if (eventArgsType is null)
                        continue;

                    if (!EventIsOk(ev))
                    {
                        errors.Add(
                            $"ERROR: Event '{ev.Name}' of type '{handlerType}' is unsupported.");
                        continue;
                    }

                    var inheritDocDecl
                        = $"{indent2}/// <inheritdoc cref=\"{TypeName}.{ev.Name}\"/>";

                    var generatedDecl
                        = $"{indent2}public event {TypeToCodeString(handlerType)}? {ev.Name};";

                    Console.WriteLine(generatedDecl);
                    if (first)
                        first = false;
                    else
                        generatedFile.Add(string.Empty);
                    generatedFile.Add(inheritDocDecl);
                    generatedFile.Add(generatedDecl);

                    GenerateRaiseMethod();
                    GenerateOnEventMethod();
                    GenerateHandlerMethod();

                    void GenerateHandlerMethod()
                    {
                        var tString = TypeToCodeString(eventArgsType);

                        var generatedDecl1
                            = $"{indent2}private void {ev.Name}Handler(object? sender, {tString} e)";
                        var generatedDecl2 = $"{indent2}{{";
                        var generatedDecl3 = $"{indent3}Raise{ev.Name}(e);";
                        var generatedDecl4 = $"{indent2}}}";
                        privates.Add(string.Empty);
                        privates.Add(generatedDecl1);
                        privates.Add(generatedDecl2);
                        privates.Add(generatedDecl3);
                        privates.Add(generatedDecl4);
                    }

                    void GenerateRaiseMethod()
                    {
                        var tString = TypeToCodeString(eventArgsType);

                        var generatedDecl1
                            = $"{indent2}internal void Raise{ev.Name}({tString} e)";
                        var generatedDecl2 = $"{indent2}{{";
                        var generatedDecl3 = $"{indent3}{ev.Name}?.Invoke(this, e);";
                        var generatedDecl4 = $"{indent3}On{ev.Name}(e);";
                        var generatedDecl5 = $"{indent2}}}";
                        internals.Add(string.Empty);
                        internals.Add(generatedDecl1);
                        internals.Add(generatedDecl2);
                        internals.Add(generatedDecl3);
                        internals.Add(generatedDecl4);
                        internals.Add(generatedDecl5);
                    }

                    void GenerateOnEventMethod()
                    {
                        var tString = TypeToCodeString(eventArgsType);

                        var generatedDecl1
                            = $"{indent2}/// Raised when <see cref=\"{ev.Name}\"/> event is called.";
                        var generatedDecl2
                            = $"{indent2}protected virtual void On{ev.Name}({tString} e)";
                        var generatedDecl3 = $"{indent2}{{";
                        var generatedDecl4 = $"{indent2}}}";
                        protecteds.Add(string.Empty);
                        protecteds.Add(generatedDecl1);
                        protecteds.Add(generatedDecl2);
                        protecteds.Add(generatedDecl3);
                        protecteds.Add(generatedDecl4);
                    }
                }
            }
        }

        public void Prepare()
        {
            if(!string.IsNullOrEmpty(RootFolder))
                RootFolder = Path.GetFullPath(RootFolder);
            
            PathToDll = ReplaceParams(PathToDll);
            PathToResult = ReplaceParams(PathToResult);

            string? ReplaceParams(string? s)
            {
                if (s is null)
                    return null;
                if (!string.IsNullOrEmpty(RootFolder))
                {
                    var result = s.Replace("$(RootFolder)", RootFolder);
                    return result;
                }

                return s;
            }
        }
    }
}
