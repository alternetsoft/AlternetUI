using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

using Alternet.UI.Extensions;

namespace Alternet.UI
{
    public class GenerateBindableSetting
    {
        public static string Copyright => $"Copyright (c) {DateTime.Now.Year} AlterNET Software";
        public static string HeaderText =>
            $"// <auto-generated> DO NOT MODIFY MANUALLY. {Copyright}.</auto-generated>";

        public string? RootFolder { get; set; }

        public string? PathToDll { get; set; }

        public string? TypeName { get; set; }

        public string? PathToResult { get; set; }

        public string? ResultTypeName { get; set; }

        public string? SubPropertyName { get; set; }

        public bool? Ignore { get; set; }

        public static PathAssemblyResolver CreateAssemblyResolver(string pathToDll)
        {
            var folder = Path.GetDirectoryName(pathToDll);
            string[] runtimeAssemblies = Directory.GetFiles(folder!, "*.dll");
            var paths = new List<string>(runtimeAssemblies);
            
            paths.Add(typeof(object).Assembly.Location);

            var runTimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");

            paths.AddRange(runTimeAssemblies);

            var resolver = new PathAssemblyResolver(paths);
            return resolver;
        }

        public bool Execute(GenerateBindableSettings globals)
        {
            if (PathToDll is null || TypeName is null || PathToResult is null || ResultTypeName is null)
                return false;

            var indent = "    ";

            var resolver = CreateAssemblyResolver(PathToDll);

            using var mlc = new MetadataLoadContext(resolver);

            Assembly assembly = mlc.LoadFromAssemblyPath(PathToDll);
            AssemblyName name = assembly.GetName();

            var type = assembly.GetType(TypeName);

            if(type is null)
            {
                Console.WriteLine($"Type is not found: {TypeName}");
                return false;
            }

            List<string> generatedFile = new();

            var lastPointPos = ResultTypeName.LastIndexOf('.');

            if (lastPointPos <= 0)
                return false;

            var resultNamespace = ResultTypeName.Substring(0, lastPointPos);
            var resultTypeNameOnly = ResultTypeName.Substring(lastPointPos + 1);

            generatedFile.Add(HeaderText);
            /* generatedFile.Add("#pragma warning disable"); */
            generatedFile.Add($"namespace {resultNamespace}");
            generatedFile.Add("{");

            generatedFile.Add($"{indent}public partial class {resultTypeNameOnly}");
            generatedFile.Add($"{indent}{{");


            void GenerateProperties()
            {
                var props = type.GetProperties(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);

                Console.WriteLine();
                Console.WriteLine("Properties:");
                Console.WriteLine();

                foreach (var prop in props)
                {
                    var canWrite = prop.CanWrite
                        ? $"set => {SubPropertyName}.{prop.Name} = value; " : string.Empty;
                    var canRead = prop.CanRead
                        ? $"get => {SubPropertyName}.{prop.Name}; " : string.Empty;
                    var propType = ChangeAliasedType(prop.PropertyType);
                    if (propType is null)
                        continue;
                    if (!TypeNameIsValid(propType.TrimEnd('[', ']', ',')))
                    {
                        Console.WriteLine($"Property '{prop.Name}' has unsupported type: {propType}");
                        continue;
                    }

                    var realType = AssemblyUtils.GetRealType(prop.PropertyType);
                    var typeCode = Type.GetTypeCode(realType);

                    /*
                    if (typeCode == TypeCode.Object || !realType.IsValueType)
                        continue;
                    */

                    var inheritDocDecl
                        = $"{indent}{indent}/// <inheritdoc cref=\"{TypeName}.{prop.Name}\"/>";

                    var generatedDecl
                        = $"{indent}{indent}public {propType} {prop.Name} {{ {canRead}{canWrite}}}";

                    Console.WriteLine(generatedDecl);
                    generatedFile.Add(inheritDocDecl);
                    generatedFile.Add(generatedDecl);
                    generatedFile.Add(string.Empty);
                }
            }

            GenerateProperties();
            GenerateEvents();

            generatedFile.Add($"{indent}}}");
            generatedFile.Add("}");

            File.Delete(PathToResult);

            var s = StringUtils.ToString(
                generatedFile,
                string.Empty,
                string.Empty,
                Environment.NewLine);

            using var stream = File.Create(PathToResult);

            StreamUtils.StringToStream(stream, s);

            stream.Flush();
            stream.Close();

            Console.WriteLine();
            Console.WriteLine();

            return true;

            bool TypeNameIsValid(string? typeNameToCheck)
            {
                return StringUtils.HasOnlyValidChars(typeNameToCheck, StringUtils.IsEnglishCharOrDot);
            }

            string? ChangeAliasedType(Type? type)
            {
                var t = type?.FullName;

                if (t is null)
                    return null;

                if (type?.IsArray ?? false)
                    return t;

                foreach (var item in globals.TypeAliases)
                {
                    if (item.TypeName == t)
                    {
                        return item.ChangeTo;
                    }
                }

                return t;
            }

            void GenerateEvents()
            {
                var events = type.GetEvents(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);

                Console.WriteLine();
                Console.WriteLine("Events:");
                Console.WriteLine();

                foreach (var ev in events)
                {
                    var evText = ev.ToString();

                    var handlerTypeName = ev.EventHandlerType?.ToString();

                    if (handlerTypeName is null)
                        continue;
                    if(!TypeNameIsValid(handlerTypeName))
                    {
                        Console.WriteLine($"Event '{ev.Name}' has unsupported type: {handlerTypeName}");
                        continue;
                    }

                    Console.WriteLine($"public event {handlerTypeName}? {ev.Name};");
                }
            }
        }

        public void Prepare()
        {
            if(!string.IsNullOrEmpty(RootFolder))
                RootFolder = Path.GetFullPath(RootFolder);
            
            PathToDll = ReplaceParams(PathToDll);
            PathToResult = ReplaceParams(PathToResult);

            string? ReplaceParams(string? s)
            {
                if (s is null)
                    return null;
                if (!string.IsNullOrEmpty(RootFolder))
                {
                    var result = s.Replace("$(RootFolder)", RootFolder);
                    return result;
                }

                return s;
            }
        }
    }
}
