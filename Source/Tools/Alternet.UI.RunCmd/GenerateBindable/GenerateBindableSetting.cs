using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

using Alternet.UI.Extensions;

namespace Alternet.UI
{
    public class GenerateBindableSetting
    {
        public static string Copyright => $"Copyright (c) {DateTime.Now.Year} AlterNET Software";
        public static string HeaderText =>
            $"// <auto-generated> DO NOT MODIFY MANUALLY. {Copyright}.</auto-generated>";

        public bool? DisableWarnings { get; set; }

        public string? RootFolder { get; set; }

        public string? PathToDll { get; set; }

        public string? TypeName { get; set; }

        public string? PathToResult { get; set; }

        public string? ResultTypeName { get; set; }

        public string? SubPropertyName { get; set; }

        public bool? Ignore { get; set; }

        public static PathAssemblyResolver CreateAssemblyResolver(string pathToDll)
        {
            var folder = Path.GetDirectoryName(pathToDll);
            string[] runtimeAssemblies = Directory.GetFiles(folder!, "*.dll");
            var paths = new List<string>(runtimeAssemblies);
            
            paths.Add(typeof(object).Assembly.Location);

            var runTimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");

            paths.AddRange(runTimeAssemblies);

            var resolver = new PathAssemblyResolver(paths);
            return resolver;
        }

        public bool Execute(GenerateBindableSettings globals)
        {
            if (PathToDll is null || TypeName is null || PathToResult is null || ResultTypeName is null)
                return false;

            var indent = "    ";
            var indent2 = $"{indent}{indent}";
            var indent3 = $"{indent}{indent}{indent}";

            var resolver = CreateAssemblyResolver(PathToDll);

            using var mlc = new MetadataLoadContext(resolver);

            Assembly assembly = mlc.LoadFromAssemblyPath(PathToDll);
            AssemblyName name = assembly.GetName();

            var type = assembly.GetType(TypeName);

            if(type is null)
            {
                Console.WriteLine($"Type is not found: {TypeName}");
                return false;
            }

            List<string> generatedFile = new();
            List<string> errors = new();
            List<string> internals = new();
            List<string> protecteds = new();

            var lastPointPos = ResultTypeName.LastIndexOf('.');

            if (lastPointPos <= 0)
                return false;

            var resultNamespace = ResultTypeName.Substring(0, lastPointPos);
            var resultTypeNameOnly = ResultTypeName.Substring(lastPointPos + 1);

            generatedFile.Add(HeaderText);

            if(DisableWarnings ?? false)
                generatedFile.Add("#pragma warning disable");

            generatedFile.Add("#nullable enable");

            generatedFile.Add($"namespace {resultNamespace}");
            generatedFile.Add("{");
            generatedFile.Add($"{indent}public partial class {resultTypeNameOnly}");
            generatedFile.Add($"{indent}{{");

            void GenerateProperties(bool first)
            {
                var props = type.GetProperties(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);

                Console.WriteLine();
                Console.WriteLine("Properties:");
                Console.WriteLine();

                foreach (var prop in props)
                {
                    var canWrite = prop.CanWrite
                        ? $"set => {SubPropertyName}.{prop.Name} = value; " : string.Empty;
                    var canRead = prop.CanRead
                        ? $"get => {SubPropertyName}.{prop.Name}; " : string.Empty;
                    var propType = ChangeAliasedType(prop.PropertyType);
                    if (propType is null)
                        continue;
                    if (!TypeNameIsValid(propType.TrimEnd('[', ']', ',')))
                    {
                        errors.Add($"Property '{prop.Name}' has unsupported type: {propType}");
                        continue;
                    }

                    var realType = AssemblyUtils.GetRealType(prop.PropertyType);
                    var typeCode = Type.GetTypeCode(realType);

                    var inheritDocDecl
                        = $"{indent2}/// <inheritdoc cref=\"{TypeName}.{prop.Name}\"/>";

                    var generatedDecl
                        = $"{indent2}public {propType} {prop.Name} {{ {canRead}{canWrite}}}";

                    Console.WriteLine(generatedDecl);
                    if (first)
                        first = false;
                    else
                        generatedFile.Add(string.Empty);
                    generatedFile.Add(inheritDocDecl);
                    generatedFile.Add(generatedDecl);
                }
            }

            GenerateEvents(true);
            GenerateProperties(false);

            EnumerableUtils.ForEach(internals, generatedFile.Add);
            EnumerableUtils.ForEach(protecteds, generatedFile.Add);

            generatedFile.Add($"{indent}}}");
            generatedFile.Add("}");

            File.Delete(PathToResult);

            var s = StringUtils.ToString(
                generatedFile,
                string.Empty,
                string.Empty,
                Environment.NewLine);

            using var stream = File.Create(PathToResult);
            StreamUtils.StringToStream(stream, s);

            stream.Flush();
            stream.Close();

            if (errors.Count > 0)
            {
                Console.WriteLine();
                Console.WriteLine("Errors:");
                Console.WriteLine();
                EnumerableUtils.ForEach(errors, Console.WriteLine);
                Console.WriteLine();
            }

            Console.WriteLine();
            Console.WriteLine();

            return true;

            bool TypeNameIsValid(string? typeNameToCheck)
            {
                return StringUtils.HasOnlyValidChars(typeNameToCheck, StringUtils.IsEnglishCharOrDot);
            }

            string? ChangeAliasedType(Type? type)
            {
                var t = type?.FullName;

                if (t is null)
                    return null;

                if (type?.IsArray ?? false)
                    return t;

                foreach (var item in globals.TypeAliases)
                {
                    if (item.TypeName == t)
                    {
                        return item.ChangeTo;
                    }
                }

                return t;
            }

            void GenerateEvents(bool first)
            {
                var events = type.GetEvents(
                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly);

                Console.WriteLine();
                Console.WriteLine("Events:");
                Console.WriteLine();

                foreach (var ev in events)
                {
                    var evText = ev.ToString();

                    var handlerType = ev.EventHandlerType;
                    if (handlerType is null)
                        continue;

                    var eventArgsType = handlerType.GetMethod("Invoke")?.GetParameters()[1]?.ParameterType;
                    if (eventArgsType is null)
                        continue;

                    var handlerTypeName = handlerType.ToString();
                    if(!TypeNameIsValid(handlerTypeName))
                    {
                        errors.Add($"Event '{ev.Name}' has unsupported type: {handlerTypeName}");
                        continue;
                    }

                    var inheritDocDecl
                        = $"{indent2}/// <inheritdoc cref=\"{TypeName}.{ev.Name}\"/>";

                    var generatedDecl
                        = $"{indent2}public event {handlerTypeName}? {ev.Name};";

                    Console.WriteLine(generatedDecl);
                    if (first)
                        first = false;
                    else
                        generatedFile.Add(string.Empty);
                    generatedFile.Add(inheritDocDecl);
                    generatedFile.Add(generatedDecl);

                    GenerateRaiseCall();
                    GenerateOnEventCall();

                    void GenerateRaiseCall()
                    {
                        var generatedDecl1
                            = $"{indent2}internal void Raise{ev.Name}({eventArgsType.FullName} e)";
                        var generatedDecl2 = $"{indent2}{{";
                        var generatedDecl3 = $"{indent3}{ev.Name}?.Invoke(this, e);";
                        var generatedDecl4 = $"{indent3}On{ev.Name}(e);";
                        var generatedDecl5 = $"{indent2}}}";
                        internals.Add(string.Empty);
                        internals.Add(generatedDecl1);
                        internals.Add(generatedDecl2);
                        internals.Add(generatedDecl3);
                        internals.Add(generatedDecl4);
                        internals.Add(generatedDecl5);
                    }

                    void GenerateOnEventCall()
                    {
                        var generatedDecl1
                            = $"{indent2}/// Raised when <see cref=\"{ev.Name}\"/> event is called.";
                        var generatedDecl2
                            = $"{indent2}protected virtual void On{ev.Name}({eventArgsType.FullName} e)";
                        var generatedDecl3 = $"{indent2}{{";
                        var generatedDecl4 = $"{indent2}}}";
                        protecteds.Add(string.Empty);
                        protecteds.Add(generatedDecl1);
                        protecteds.Add(generatedDecl2);
                        protecteds.Add(generatedDecl3);
                        protecteds.Add(generatedDecl4);
                    }
                }
            }
        }

        public void Prepare()
        {
            if(!string.IsNullOrEmpty(RootFolder))
                RootFolder = Path.GetFullPath(RootFolder);
            
            PathToDll = ReplaceParams(PathToDll);
            PathToResult = ReplaceParams(PathToResult);

            string? ReplaceParams(string? s)
            {
                if (s is null)
                    return null;
                if (!string.IsNullOrEmpty(RootFolder))
                {
                    var result = s.Replace("$(RootFolder)", RootFolder);
                    return result;
                }

                return s;
            }
        }
    }
}
